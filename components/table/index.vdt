import Checkbox from '../checkbox';
import Radio from '../radio';
import Row from './row';
import {normalize} from 'intact';
import Column from './column';
import {noop, isStringOrNumber} from '../utils';

const {
    checkType, scheme, checkedKeys, data, rowKey, 
    className, fixHeader, noDataTemplate, disableRow,
    resizable, expandedKeys, type, stickHeader, _isSticky,
    style, rowClassName, children, sort, group, _scrollBarWidth,
} = self.get();

let colSpan = checkType === 'checkbox' || checkType === 'radio' ? 1 : 0;
const _scheme = {};

let prevItem = checkType === 'checkbox' || checkType === 'radio' ? 
    {minWidth: 40} : {};

let hasFixedLeft;
let hasFixedRight;
self.leftColumns = [];
self.rightColumns = [];

const isInvisible = (onlyLeft, onlyRight, props) => {
    return props.fixed !== 'left' && onlyLeft || props.fixed !== 'right' && onlyRight;
}

let cols;

const TheadCreator = ({onlyLeft, onlyRight, collect}) => {
    const keys = {};
    const refLeftElement = (i) => i && self.leftColumns.push(i);
    const refLeft = (i) => i && self.leftColumns.push(i.element);
    const refRight = (i) => i && self.rightColumns.push(i.element);
    const ref = collect ? onlyLeft ? refLeft : onlyRight ? refRight : undefined : undefined;
    cols = [];
    const thead = <thead>
        <tr>
            {{ do {
                if (checkType === 'checkbox') {
                    cols.push(<col class="k-th-check" />);
                    <th class={{ {'k-invisible': onlyRight} }}
                        ref={{ collect && onlyLeft ? refLeftElement : undefined }} 
                    >
                        <Checkbox value={{ self.isCheckAll() }}
                            ev-click={{ self._toggleCheckAll }}
                        />
                    </th>
                } else if (checkType === 'radio') {
                    cols.push(<col class="k-th-check" />);
                    <th class={{ {"k-invisible": onlyRight} }}
                        ref={{ collect && onlyLeft ? refLeftElement : undefined }} 
                    ></th>
                }
            } }}
            {{ __u.map(scheme, (item, key) => {
                colSpan++;
                keys[key] = true;

                if (!__u.isObject(item) || item.type) {
                    item = {title: item};
                }

                // because we use the last resize handle to controll the previous column
                // so we bind prevItem here
                const _prevItem = prevItem;
                const dragStart = self._dragStart.bind(self, prevItem);
                prevItem = item;

                if (item.fixed === 'left') {
                    hasFixedLeft = true;
                } else if (item.fixed === 'right') {
                    hasFixedRight = true;
                }

                cols.push(<col width={{ item.width }} />);

                const invisible = isInvisible(onlyLeft, onlyRight, item);
                return <Column {{ ...item }}
                    key={{ key }}
                    $parent={{ self }} 
                    ev-click={{ item.sortable ? self._sort.bind(self, key, item) : undefined }}
                    ev-dragStart={{ dragStart }}
                    v-model={{ `group.${key}` }}
                    className={{ {
                        [item.className]: item.className,
                        'k-invisible': invisible, 
                    } }}
                    ref={{ !invisible ? ref : undefined }}
                    prevColumn={{ _prevItem }}
                />
            }) }}
            {{  // for using TableColumn as children
                __u.map(children ? (Array.isArray(children) ? children : [children]) : children, vNode => {
                    if (vNode.tag === Column) {
                        colSpan++;
                        const props = {...vNode.props, $parent: self};
                        
                        if (props.key == null) {
                            _e(new Error('key for TableColumn must be specified.'));
                        } else if (/^\d+$/.test(props.key)) {
                            // avoid digital key
                            _e(new Error('don\'t use digits as key.'));
                        } else if (keys[props.key]) {
                            _e(new Error(`Reduplicated key: ${props.key}`));
                        }

                        keys[props.key] = true;
                        props.value = group[props.key];

                        const dragStart = self._dragStart.bind(self, prevItem);
                        props.prevColumn = prevItem;
                        prevItem = props;

                        props['ev-$change:value'] = (c, v) => self.set(`group.${props.key}`, v);
                        props['ev-click'] = props.sortable ? self._sort.bind(self, props.key, props) : undefined;
                        props['ev-dragStart'] = dragStart;

                        const invisible = isInvisible(onlyLeft, onlyRight, props);
                        props.className = _className({
                            [props.className]: props.className,
                            'k-invisible': invisible, 
                        });

                        const blockFn = props._blocks && (props._blocks.default || props._blocks.template);
                        _scheme[props.key] = {
                            title: props.title,
                            fixed: props.fixed,
                            template: props.template || 
                                blockFn && ((...args) => blockFn.call(self, noop, ...args))
                        };

                        if (props.fixed === 'left') {
                            hasFixedLeft = true;
                        } else if (props.fixed === 'right') {
                            hasFixedRight = true;
                        }

                        if (!invisible) {
                            props.ref = ref; 
                        }

                        cols.push(<col width={{ props.width }} />);

                        // clone vNode
                        return h(Column, props);
                    }
                }) 
            }}
        </tr>
    </thead>

    return <div class="k-thead">
        <table>
            <colgroup>{{ cols }}</colgroup>
            {{ thead }}
        </table>
    </div>
};

const TbodyCreator = ({onlyLeft, onlyRight}) => {
    const tbody = <tbody>
        {{ data && data.length ? 
            __u.map(data, (value, index) => {
                const key = rowKey.call(self, value, index);
                const disabled = disableRow.call(self, value, index);
                const className = rowClassName.call(self, value, index);
                const tr = <Row key={{ key }}
                    ev-click={{ self._clickRow.bind(self, value, index, key) }}
                    class={{ {
                        'k-disabled': disabled,
                        [className]: className,
                        'k-checked': self.isChecked(key), 
                    } }}
                    ev-$destroyed={{ self._onRowDestroyed.bind(self, key) }}
                >
                    <td v-if={{ checkType === 'checkbox' }}
                        class={{ {'k-invisible': onlyRight} }}
                    >
                        <Checkbox v-model="checkedKeys" name="k-table-checkbox"
                            trueValue={{ key }}
                            disabled={{ disabled }}
                        />
                    </td>
                    <td v-else-if={{ checkType === 'radio' }}
                        class={{ {'k-invisible': onlyRight} }}
                    >
                        <Radio v-model="checkedKey" name="k-table-radio"
                            trueValue={{ key }}
                            disabled={{ disabled }}
                        />
                    </td>
                    {{ __u.map(__u.extend({}, scheme, _scheme), (item, key) => {
                        let td;
                        if (__u.isObject(item) && item.template) {
                            if (typeof item.template === 'function') {
                                td = item.template.call(self, value, index);
                                // for Intact-Vue
                                if (normalize) {
                                    td = normalize(td);
                                }
                            } else {
                                td = item.template;
                            }
                        } else if (value[key] !== undefined) {
                            td = value[key];
                        } else {
                            let obj = value,
                                keys = key.split('.'),
                                i = 0;
                            while (obj != null && i < keys.length) {
                                obj = obj[keys[i++]];
                            }
                            td = (i && i === keys.length) ? obj : null;
                        }
                        return <td title={{ isStringOrNumber(td) ? td : undefined }}
                            className={{ {
                                'k-invisible': isInvisible(onlyLeft, onlyRight, item),
                            } }}
                        >
                            {{ typeof td === 'boolean' ? String(td) : td }}
                        </td>
                    }) }}
                </Row>;

                if (blocks.expand && expandedKeys.indexOf(key) > -1) {
                    return [
                        tr,
                        <tr class="k-expand" key={{ `${key}.expand` }}>
                            <td colspan={{ colSpan }}>
                                <b:expand args={{ [value, index] }} />
                            </td>
                        </tr>
                    ]
                } else {
                    return tr;
                }
            }) :
            <tr key="table_no_data">
                <td colspan={{ colSpan }} class="k-no-data">
                    <b:no-data>{{ noDataTemplate }}</b:no-data>
                </td>
            </tr>
        }}
    </tbody>

    return <div class="k-tbody">
        <table>
            <colgroup>{{ cols }}</colgroup>
            {{ tbody }}
        </table>
    </div>
};

const classNameObj = {
    'k-table-wrapper': true,
    [className]: className,
    [`k-${type}`]: type !== 'default',
    'k-sticky': _isSticky, 
};

const table = <div class="k-table"
    ref={{ dom => self.table = dom }}
>
    <TheadCreator useRef />
    <TbodyCreator />
</div>

return table;

self.hasFixedLeft = hasFixedLeft;
self.hasFixedRight = hasFixedRight;

let index = 0;
const Wrapper = (props) => {
    const ret = <div class={{ __u.extend({}, classNameObj, {
        [props.className]: props.className
    }) }} style={{ props.style }}>
        <div v-if={{ fixHeader || _isSticky }} class="k-fixed-scroll"
            style={{ props.tableStyle }}
        >
            <div class="k-fixed"
                style={{ do {
                    const style = {paddingRight: self.get('_padding') + 'px'};
                    if (_isSticky) {
                        const _sticky = self.get('_sticky');
                        __u.extend(style, _sticky);
                    }
                    style;
                } }}
                ref={{ props.useRef ? dom => self.header = dom : undefined }}
            >
                <table class="k-table" ref={{ props.useRef ? dom => self.headerTable = dom : undefined }}>
                    <TheadCreator onlyLeft={{ props.onlyLeft }} onlyRight={{ props.onlyRight }} />
                </table>
            </div>
            <div class="k-scroll"
                style={{ do {
                    let style = {};
                    if (!_isSticky &&
                        (typeof fixHeader === 'number' || 
                        typeof fixHeader === 'string')
                    ) {
                        style = {maxHeight: `${fixHeader - (props.onlyLeft || props.onlyRight ? _scrollBarWidth : 0)}px`};
                    } else if (_isSticky && self.get('_sticky.position')) {
                        style = {paddingTop: self.get('_headerHeight')};
                    }
                    style;
                } }}
                ref={{ props.useRef ? dom => self.scroll = dom : undefined }}
            >{{ props.children }}</div>
        </div>
        <template v-else>{{ props.children }}</template>
    </div>;

    index++;

    return ret;
};

<template>
    <div v-if={{ hasFixedLeft || hasFixedRight }} class="k-table-fixed-column" style={{ style }}>
        <Wrapper useRef>{{ table }}</Wrapper>
        <Wrapper v-if={{ hasFixedLeft }} class="k-fixed-left" onlyLeft
            style={{ {width: self.get('_leftWidth') + 'px'} }}
            tableStyle={{ {width: self.get('_tableWidth') + 'px'} }}
        >
            <table class="k-table">
                <TheadCreator onlyLeft/>
                <TbodyCreator onlyLeft />
            </table>
        </Wrapper>
        <Wrapper v-if={{ hasFixedRight }} class="k-fixed-right" onlyRight 
            style={{ {width: self.get('_rightWidth') + 'px'} }}
            tableStyle={{ {width: self.get('_tableWidth') + 'px'} }}
        >
            <table class="k-table">
                <TheadCreator onlyRight />
                <TbodyCreator onlyRight />
            </table>
        </Wrapper>
    </div>
    <Wrapper v-else style={{ style }} useRef>{{ table }}</Wrapper>
</template>
